# -*- coding: utf-8 -*-
"""processamento_imagens_ativ2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zyIH3Tf05go8p6YvUOTffj4FBCZMvsWx
"""

# Assignment 2 - Fourier Transform and Filtering in Frequency Domain - Bruna Correa Araujo Castro - 11819702 - SCC0251 - 2024/1

import numpy as np
import imageio.v3 as imageio

# filtro low pass
def low_pass(I,r):
  # matriz transformada
  D = np.zeros(I.shape)
  # imagem final
  H = np.zeros(I.shape)
  # largura e altura da imagem
  n,m = I.shape
  # itera sobre cada elemento da imagem, pelas linhas e colunas
  for u in range(n):
    for v in range(m):
      # filtro ideal sobre o elemento
      D[u][v] = np.sqrt((u - n/2)**2+(v - m/2)**2)
      # se é menor que o limite escolhido, imagem final recebe pixel branco no elemento (u,v)
      if D[u][v] <= r:
        H[u][v] = 1
      # se é maior que o limite escolhido, imagem final recebe pixel preto no elemento (u,v)
      else:
        H[u][v] = 0
  return H

# filtro high pass
def high_pass(I,r):
  # matriz transformada
  D = np.zeros(I.shape)
  # imagem final
  H = np.zeros(I.shape)
  # largura e altura da imagem
  n,m = I.shape
  # itera sobre cada elemento da imagem, pelas linhas e colunas
  for u in range(n):
    for v in range(m):
      # filtro ideal sobre o elemento
      D[u][v] = np.sqrt((u - n/2)**2+(v - m/2)**2)
      # se é menor que o limite escolhido, imagem final recebe pixel preto no elemento (u,v)
      if D[u][v] <= r:
        H[u][v] = 0
      # se é maior que o limite escolhido, imagem final recebe pixel branco no elemento (u,v)
      else:
        H[u][v] = 1
  return H

# função passa banda (band stop)
def band_stop(I, r0, r1):
  D = np.zeros(I.shape)
  H = np.zeros(I.shape)
  n,m = I.shape
  for u in range(n):
    for v in range(m):
      D[u][v] = np.sqrt((u - n/2)**2+(v - m/2)**2)
      # se o elemento do filtro está entre r1 e r0, imagem final recebe pixel preto no elemento (u,v)
      if D[u][v] <= r0 and D[u][v] >= r1:
        H[u][v] = 0
      # se não, imagem final recebe pixel branco no elemento (u,v)
      else:
        H[u][v] = 1
  return H

# laplacian
def laplacian(I):
  H = np.zeros(I.shape)
  n,m = I.shape
  for u in range(n):
    for v in range(m):
      # operador laplaciano gera elemento novo da imagem final
      H[u][v] = -4*(np.pi**2)*((u-n/2)**2+(v-m/2)**2)
  return H

# gaussian
def gaussian(I, z0, z1):
  H = np.zeros(I.shape)
  n,m = I.shape
  for u in range(n):
    for v in range(m):
      # operador gaussiano gera elemento novo da imagem final
      x = ( u - n/2 )**2/(2*(z0**2)) + ( v - m/2 )**2/(2*(z1**2))
      H[u][v] = np.exp(-x)
  return H

# transformada discreta de fourier passo a passo
def transf_fourier(I, index):
  # transformada rápida de fourier
  fft = np.fft.fft2(I)

  # centralizar as baixas frequencias
  low_fft = np.fft.fftshift(fft)

  # selecionar o filtro pelo indice de input
  if index == 0:
    M = low_pass(I,r)

  if index == 1:
    M = high_pass(I,r)

  if index == 2:
    M = band_stop(I,r0,r1)

  if index == 3:
    M = laplacian(I)

  if index == 4:
    M = gaussian(I,z0,z1)

  # multiplicar por M
  G_linha = np.multiply(M,low_fft)

  # inverter para os cantos
  inverte = np.fft.ifftshift(G_linha)

  # computar a inversa e ter a imagem restaurada
  G = np.fft.ifft2(inverte)
  n,m = G.shape

  # pegar a parte real
  G_real = np.real(G)

  # normalizar e arredondar o resultado
  G_norm = np.round((G_real - np.min(G_real)) * (255/(np.max(G_real)-np.min(G_real))))

  # comparar a imagem original e filtrada
  result = np.sqrt( 1/(m*n) * np.sum((H - G_norm)**2) )

  # printar o resultado arredondado para 4 casas
  print(round(result,4))


I = imageio.imread(input().rstrip()) # input image
H = imageio.imread(input().rstrip()) # reference image
index = int(input().rstrip())  # indices para filtros, retirando o espaço ao final

# low ou high pass: recebe o limite
if index <= 1:
  r = float(input().rstrip())

# band stop: recebe duas entradas, limite superior e inferior
if index == 2:
  r0 = float(input().rstrip())
  r1 = float(input().rstrip())

# gauss: recebe duas entradas
if index == 4:
  z0 = float(input().rstrip())
  z1 = float(input().rstrip())

transf_fourier(I,index)

